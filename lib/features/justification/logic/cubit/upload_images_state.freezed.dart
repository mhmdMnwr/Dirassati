// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'upload_images_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$UploadImagesState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UploadImagesStateCopyWith<T, $Res> {
  factory $UploadImagesStateCopyWith(UploadImagesState<T> value,
          $Res Function(UploadImagesState<T>) then) =
      _$UploadImagesStateCopyWithImpl<T, $Res, UploadImagesState<T>>;
}

/// @nodoc
class _$UploadImagesStateCopyWithImpl<T, $Res,
        $Val extends UploadImagesState<T>>
    implements $UploadImagesStateCopyWith<T, $Res> {
  _$UploadImagesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<T, $Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl<T> value, $Res Function(_$InitialImpl<T>) then) =
      __$$InitialImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$InitialImpl<T>>
    implements _$$InitialImplCopyWith<T, $Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl<T> _value, $Res Function(_$InitialImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl<T> implements _Initial<T> {
  const _$InitialImpl();

  @override
  String toString() {
    return 'UploadImagesState<$T>.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial<T> implements UploadImagesState<T> {
  const factory _Initial() = _$InitialImpl<T>;
}

/// @nodoc
abstract class _$$UploadLoadingImplCopyWith<T, $Res> {
  factory _$$UploadLoadingImplCopyWith(_$UploadLoadingImpl<T> value,
          $Res Function(_$UploadLoadingImpl<T>) then) =
      __$$UploadLoadingImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UploadLoadingImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$UploadLoadingImpl<T>>
    implements _$$UploadLoadingImplCopyWith<T, $Res> {
  __$$UploadLoadingImplCopyWithImpl(_$UploadLoadingImpl<T> _value,
      $Res Function(_$UploadLoadingImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UploadLoadingImpl<T> implements UploadLoading<T> {
  const _$UploadLoadingImpl();

  @override
  String toString() {
    return 'UploadImagesState<$T>.uploadLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UploadLoadingImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return uploadLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return uploadLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (uploadLoading != null) {
      return uploadLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return uploadLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return uploadLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (uploadLoading != null) {
      return uploadLoading(this);
    }
    return orElse();
  }
}

abstract class UploadLoading<T> implements UploadImagesState<T> {
  const factory UploadLoading() = _$UploadLoadingImpl<T>;
}

/// @nodoc
abstract class _$$UploadSuccessImplCopyWith<T, $Res> {
  factory _$$UploadSuccessImplCopyWith(_$UploadSuccessImpl<T> value,
          $Res Function(_$UploadSuccessImpl<T>) then) =
      __$$UploadSuccessImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T uploadResponse});
}

/// @nodoc
class __$$UploadSuccessImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$UploadSuccessImpl<T>>
    implements _$$UploadSuccessImplCopyWith<T, $Res> {
  __$$UploadSuccessImplCopyWithImpl(_$UploadSuccessImpl<T> _value,
      $Res Function(_$UploadSuccessImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uploadResponse = freezed,
  }) {
    return _then(_$UploadSuccessImpl<T>(
      freezed == uploadResponse
          ? _value.uploadResponse
          : uploadResponse // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$UploadSuccessImpl<T> implements UploadSuccess<T> {
  const _$UploadSuccessImpl(this.uploadResponse);

  @override
  final T uploadResponse;

  @override
  String toString() {
    return 'UploadImagesState<$T>.uploadSuccess(uploadResponse: $uploadResponse)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UploadSuccessImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.uploadResponse, uploadResponse));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(uploadResponse));

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UploadSuccessImplCopyWith<T, _$UploadSuccessImpl<T>> get copyWith =>
      __$$UploadSuccessImplCopyWithImpl<T, _$UploadSuccessImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return uploadSuccess(uploadResponse);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return uploadSuccess?.call(uploadResponse);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (uploadSuccess != null) {
      return uploadSuccess(uploadResponse);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return uploadSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return uploadSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (uploadSuccess != null) {
      return uploadSuccess(this);
    }
    return orElse();
  }
}

abstract class UploadSuccess<T> implements UploadImagesState<T> {
  const factory UploadSuccess(final T uploadResponse) = _$UploadSuccessImpl<T>;

  T get uploadResponse;

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UploadSuccessImplCopyWith<T, _$UploadSuccessImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UploadErrorImplCopyWith<T, $Res> {
  factory _$$UploadErrorImplCopyWith(_$UploadErrorImpl<T> value,
          $Res Function(_$UploadErrorImpl<T>) then) =
      __$$UploadErrorImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$UploadErrorImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$UploadErrorImpl<T>>
    implements _$$UploadErrorImplCopyWith<T, $Res> {
  __$$UploadErrorImplCopyWithImpl(
      _$UploadErrorImpl<T> _value, $Res Function(_$UploadErrorImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$UploadErrorImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UploadErrorImpl<T> implements UploadError<T> {
  const _$UploadErrorImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'UploadImagesState<$T>.uploadError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UploadErrorImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UploadErrorImplCopyWith<T, _$UploadErrorImpl<T>> get copyWith =>
      __$$UploadErrorImplCopyWithImpl<T, _$UploadErrorImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return uploadError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return uploadError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (uploadError != null) {
      return uploadError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return uploadError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return uploadError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (uploadError != null) {
      return uploadError(this);
    }
    return orElse();
  }
}

abstract class UploadError<T> implements UploadImagesState<T> {
  const factory UploadError({required final String error}) =
      _$UploadErrorImpl<T>;

  String get error;

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UploadErrorImplCopyWith<T, _$UploadErrorImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchLoadingImplCopyWith<T, $Res> {
  factory _$$FetchLoadingImplCopyWith(_$FetchLoadingImpl<T> value,
          $Res Function(_$FetchLoadingImpl<T>) then) =
      __$$FetchLoadingImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$FetchLoadingImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$FetchLoadingImpl<T>>
    implements _$$FetchLoadingImplCopyWith<T, $Res> {
  __$$FetchLoadingImplCopyWithImpl(
      _$FetchLoadingImpl<T> _value, $Res Function(_$FetchLoadingImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FetchLoadingImpl<T> implements FetchLoading<T> {
  const _$FetchLoadingImpl();

  @override
  String toString() {
    return 'UploadImagesState<$T>.fetchLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchLoadingImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return fetchLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return fetchLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (fetchLoading != null) {
      return fetchLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return fetchLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return fetchLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (fetchLoading != null) {
      return fetchLoading(this);
    }
    return orElse();
  }
}

abstract class FetchLoading<T> implements UploadImagesState<T> {
  const factory FetchLoading() = _$FetchLoadingImpl<T>;
}

/// @nodoc
abstract class _$$FetchSuccessImplCopyWith<T, $Res> {
  factory _$$FetchSuccessImplCopyWith(_$FetchSuccessImpl<T> value,
          $Res Function(_$FetchSuccessImpl<T>) then) =
      __$$FetchSuccessImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T uploadResponse});
}

/// @nodoc
class __$$FetchSuccessImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$FetchSuccessImpl<T>>
    implements _$$FetchSuccessImplCopyWith<T, $Res> {
  __$$FetchSuccessImplCopyWithImpl(
      _$FetchSuccessImpl<T> _value, $Res Function(_$FetchSuccessImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uploadResponse = freezed,
  }) {
    return _then(_$FetchSuccessImpl<T>(
      freezed == uploadResponse
          ? _value.uploadResponse
          : uploadResponse // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$FetchSuccessImpl<T> implements FetchSuccess<T> {
  const _$FetchSuccessImpl(this.uploadResponse);

  @override
  final T uploadResponse;

  @override
  String toString() {
    return 'UploadImagesState<$T>.fetchSuccess(uploadResponse: $uploadResponse)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchSuccessImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.uploadResponse, uploadResponse));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(uploadResponse));

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchSuccessImplCopyWith<T, _$FetchSuccessImpl<T>> get copyWith =>
      __$$FetchSuccessImplCopyWithImpl<T, _$FetchSuccessImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return fetchSuccess(uploadResponse);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return fetchSuccess?.call(uploadResponse);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (fetchSuccess != null) {
      return fetchSuccess(uploadResponse);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return fetchSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return fetchSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (fetchSuccess != null) {
      return fetchSuccess(this);
    }
    return orElse();
  }
}

abstract class FetchSuccess<T> implements UploadImagesState<T> {
  const factory FetchSuccess(final T uploadResponse) = _$FetchSuccessImpl<T>;

  T get uploadResponse;

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FetchSuccessImplCopyWith<T, _$FetchSuccessImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchErrorImplCopyWith<T, $Res> {
  factory _$$FetchErrorImplCopyWith(
          _$FetchErrorImpl<T> value, $Res Function(_$FetchErrorImpl<T>) then) =
      __$$FetchErrorImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$FetchErrorImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$FetchErrorImpl<T>>
    implements _$$FetchErrorImplCopyWith<T, $Res> {
  __$$FetchErrorImplCopyWithImpl(
      _$FetchErrorImpl<T> _value, $Res Function(_$FetchErrorImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$FetchErrorImpl<T>(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FetchErrorImpl<T> implements FetchError<T> {
  const _$FetchErrorImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'UploadImagesState<$T>.fetchError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchErrorImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchErrorImplCopyWith<T, _$FetchErrorImpl<T>> get copyWith =>
      __$$FetchErrorImplCopyWithImpl<T, _$FetchErrorImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return fetchError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return fetchError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (fetchError != null) {
      return fetchError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return fetchError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return fetchError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (fetchError != null) {
      return fetchError(this);
    }
    return orElse();
  }
}

abstract class FetchError<T> implements UploadImagesState<T> {
  const factory FetchError({required final String error}) = _$FetchErrorImpl<T>;

  String get error;

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FetchErrorImplCopyWith<T, _$FetchErrorImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EditImplCopyWith<T, $Res> {
  factory _$$EditImplCopyWith(
          _$EditImpl<T> value, $Res Function(_$EditImpl<T>) then) =
      __$$EditImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$EditImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$EditImpl<T>>
    implements _$$EditImplCopyWith<T, $Res> {
  __$$EditImplCopyWithImpl(
      _$EditImpl<T> _value, $Res Function(_$EditImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EditImpl<T> implements Edit<T> {
  const _$EditImpl();

  @override
  String toString() {
    return 'UploadImagesState<$T>.edit()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EditImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return edit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return edit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (edit != null) {
      return edit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return edit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return edit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (edit != null) {
      return edit(this);
    }
    return orElse();
  }
}

abstract class Edit<T> implements UploadImagesState<T> {
  const factory Edit() = _$EditImpl<T>;
}

/// @nodoc
abstract class _$$EliminateImplCopyWith<T, $Res> {
  factory _$$EliminateImplCopyWith(
          _$EliminateImpl<T> value, $Res Function(_$EliminateImpl<T>) then) =
      __$$EliminateImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$EliminateImplCopyWithImpl<T, $Res>
    extends _$UploadImagesStateCopyWithImpl<T, $Res, _$EliminateImpl<T>>
    implements _$$EliminateImplCopyWith<T, $Res> {
  __$$EliminateImplCopyWithImpl(
      _$EliminateImpl<T> _value, $Res Function(_$EliminateImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of UploadImagesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EliminateImpl<T> implements Eliminate<T> {
  const _$EliminateImpl();

  @override
  String toString() {
    return 'UploadImagesState<$T>.eliminate()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EliminateImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() uploadLoading,
    required TResult Function(T uploadResponse) uploadSuccess,
    required TResult Function(String error) uploadError,
    required TResult Function() fetchLoading,
    required TResult Function(T uploadResponse) fetchSuccess,
    required TResult Function(String error) fetchError,
    required TResult Function() edit,
    required TResult Function() eliminate,
  }) {
    return eliminate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? uploadLoading,
    TResult? Function(T uploadResponse)? uploadSuccess,
    TResult? Function(String error)? uploadError,
    TResult? Function()? fetchLoading,
    TResult? Function(T uploadResponse)? fetchSuccess,
    TResult? Function(String error)? fetchError,
    TResult? Function()? edit,
    TResult? Function()? eliminate,
  }) {
    return eliminate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? uploadLoading,
    TResult Function(T uploadResponse)? uploadSuccess,
    TResult Function(String error)? uploadError,
    TResult Function()? fetchLoading,
    TResult Function(T uploadResponse)? fetchSuccess,
    TResult Function(String error)? fetchError,
    TResult Function()? edit,
    TResult Function()? eliminate,
    required TResult orElse(),
  }) {
    if (eliminate != null) {
      return eliminate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(UploadLoading<T> value) uploadLoading,
    required TResult Function(UploadSuccess<T> value) uploadSuccess,
    required TResult Function(UploadError<T> value) uploadError,
    required TResult Function(FetchLoading<T> value) fetchLoading,
    required TResult Function(FetchSuccess<T> value) fetchSuccess,
    required TResult Function(FetchError<T> value) fetchError,
    required TResult Function(Edit<T> value) edit,
    required TResult Function(Eliminate<T> value) eliminate,
  }) {
    return eliminate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(UploadLoading<T> value)? uploadLoading,
    TResult? Function(UploadSuccess<T> value)? uploadSuccess,
    TResult? Function(UploadError<T> value)? uploadError,
    TResult? Function(FetchLoading<T> value)? fetchLoading,
    TResult? Function(FetchSuccess<T> value)? fetchSuccess,
    TResult? Function(FetchError<T> value)? fetchError,
    TResult? Function(Edit<T> value)? edit,
    TResult? Function(Eliminate<T> value)? eliminate,
  }) {
    return eliminate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(UploadLoading<T> value)? uploadLoading,
    TResult Function(UploadSuccess<T> value)? uploadSuccess,
    TResult Function(UploadError<T> value)? uploadError,
    TResult Function(FetchLoading<T> value)? fetchLoading,
    TResult Function(FetchSuccess<T> value)? fetchSuccess,
    TResult Function(FetchError<T> value)? fetchError,
    TResult Function(Edit<T> value)? edit,
    TResult Function(Eliminate<T> value)? eliminate,
    required TResult orElse(),
  }) {
    if (eliminate != null) {
      return eliminate(this);
    }
    return orElse();
  }
}

abstract class Eliminate<T> implements UploadImagesState<T> {
  const factory Eliminate() = _$EliminateImpl<T>;
}
